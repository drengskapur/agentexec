
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">omnivex/cmd/combine.go (0.0%)</option>
				
				<option value="file1">omnivex/cmd/root.go (0.0%)</option>
				
				<option value="file2">omnivex/cmd/version.go (0.0%)</option>
				
				<option value="file3">omnivex/main.go (0.0%)</option>
				
				<option value="file4">omnivex/pkg/combine/combine.go (0.0%)</option>
				
				<option value="file5">omnivex/pkg/version/version.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// cmd/combine.go
package cmd

import (
        "os"

        "omnivex/pkg/combine"

        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

// combineCmd represents the combine command
var combineCmd = &amp;cobra.Command{
        Use:   "combine [paths...]",
        Short: "Combine multiple files into a single output",
        Long:  `Combine multiple files into a single output, designed for workflows like ChatGPT input preparation.`,
        Args:  cobra.ArbitraryArgs, // Allow any number of positional arguments
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Retrieve the logger from the context
                logger, ok := cmd.Context().Value(loggerKey).(*zap.Logger)
                if !ok || logger == nil </span><span class="cov0" title="0">{
                        // If logger is not available, log to stderr and exit
                        os.Stderr.WriteString("Logger not initialized\n")
                        os.Exit(1)
                }</span>

                // Parse flags with error handling
                <span class="cov0" title="0">output, err := cmd.Flags().GetString("output")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'output' flag", zap.Error(err))
                }</span>
                <span class="cov0" title="0">tree, err := cmd.Flags().GetString("tree")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'tree' flag", zap.Error(err))
                }</span>
                <span class="cov0" title="0">maxSize, err := cmd.Flags().GetInt("max-size")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'max-size' flag", zap.Error(err))
                }</span>
                <span class="cov0" title="0">workers, err := cmd.Flags().GetInt("workers")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'workers' flag", zap.Error(err))
                }</span>
                <span class="cov0" title="0">ignorePatterns, err := cmd.Flags().GetStringSlice("ignore")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'ignore' flag", zap.Error(err))
                }</span>
                <span class="cov0" title="0">verbose, err := cmd.Flags().GetBool("verbose")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Failed to parse 'verbose' flag", zap.Error(err))
                }</span>

                // If no paths are specified, default to current directory
                <span class="cov0" title="0">paths := args
                if len(paths) == 0 </span><span class="cov0" title="0">{
                        paths = []string{"./"}
                }</span>

                // Define the arguments based on flags and positional arguments
                <span class="cov0" title="0">combineArgs := combine.Arguments{
                        Paths:          paths,
                        Output:         output,
                        Tree:           tree,
                        MaxFileSizeKB:  maxSize,
                        MaxWorkers:     workers,
                        IgnorePatterns: ignorePatterns, // Use ignore patterns from flags
                        Verbose:        verbose,        // Verbose logging flag
                }

                // Execute the combine process with the provided arguments
                if err := combine.ExecuteWithArgs(combineArgs, logger); err != nil </span><span class="cov0" title="0">{
                        logger.Fatal("Combine execution failed", zap.Error(err))
                }</span>
        },
}

func init() <span class="cov0" title="0">{
        // Define flags specific to the combine command
        combineCmd.Flags().StringP("output", "o", "debug/combined.txt", "Path to the combined output file")
        combineCmd.Flags().StringP("tree", "t", "debug/tree.txt", "Path to the tree structure output file")
        combineCmd.Flags().IntP("max-size", "m", 10240, "Maximum file size to process in KB (default: 10240KB)")
        combineCmd.Flags().IntP("workers", "w", 4, "Number of concurrent workers for processing files (default: 4)")
        combineCmd.Flags().StringSliceP("ignore", "i", []string{
                ".git/",
                ".combineignore",
                "debug/",
        }, "Ignore patterns (e.g., \"*.git\", \"build/\")")
        combineCmd.Flags().BoolP("verbose", "v", false, "Enable verbose logging of skipped files")
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// cmd/root.go
package cmd

import (
        "context"

        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

type contextKey string

const loggerKey contextKey = "logger"

// RootCmd is the base command when called without any subcommands
var RootCmd = &amp;cobra.Command{
        Use:   "omnivex",
        Short: "Omnivex is a CLI tool for combining files",
        Long:  `Omnivex combines multiple files into a single text file.`,
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute(logger *zap.Logger) error <span class="cov0" title="0">{
        // Create a context with the logger
        ctx := context.WithValue(context.Background(), loggerKey, logger)
        // Set the context to RootCmd
        RootCmd.SetContext(ctx)
        return RootCmd.Execute()
}</span>

func init() <span class="cov0" title="0">{
        RootCmd.AddCommand(combineCmd)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// cmd/version.go
package cmd

import (
        "fmt"
        "os"

        "omnivex/pkg/version"

        "github.com/spf13/cobra"
        "go.uber.org/zap"
)

// versionCmd represents the version command
var versionCmd = &amp;cobra.Command{
        Use:   "version",
        Short: "Display the version of Omnivex",
        Long:  `All software has versions. This is Omnivex's.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                // Retrieve the logger from the context
                logger, ok := cmd.Context().Value(loggerKey).(*zap.Logger)
                if !ok || logger == nil </span><span class="cov0" title="0">{
                        // If logger is not available, log to stderr and exit
                        fmt.Fprintln(os.Stderr, "Logger not initialized")
                        os.Exit(1)
                }</span>

                // Fetch version information
                <span class="cov0" title="0">v := version.Get()

                // Display version information to the user
                fmt.Println(v.String())

                // Log that the version command was executed
                logger.Debug("Executed version command", zap.String("version", v.Version), zap.String("commit", v.GitCommit))</span>
        },
}

func init() <span class="cov0" title="0">{
        RootCmd.AddCommand(versionCmd)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "log"
        "os"
        "runtime/debug"

        "omnivex/cmd"

        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// createLogger creates and configures the application's logger
func createLogger(verbose bool) (*zap.Logger, error) <span class="cov0" title="0">{
        // Configure encoder
        encoderConfig := zapcore.EncoderConfig{
                TimeKey:        "timestamp",
                LevelKey:       "level",
                NameKey:        "logger",
                CallerKey:      "caller",
                FunctionKey:    zapcore.OmitKey,
                MessageKey:     "msg",
                StacktraceKey:  "stacktrace",
                LineEnding:     zapcore.DefaultLineEnding,
                EncodeLevel:    zapcore.CapitalLevelEncoder,
                EncodeTime:     zapcore.ISO8601TimeEncoder,
                EncodeDuration: zapcore.SecondsDurationEncoder,
                EncodeCaller:   zapcore.ShortCallerEncoder,
        }

        // Create stdout syncer
        stdout := zapcore.AddSync(os.Stdout)

        // Determine log level based on verbose flag
        level := zap.InfoLevel
        if verbose </span><span class="cov0" title="0">{
                level = zap.DebugLevel
        }</span>

        // Create console encoder and core
        <span class="cov0" title="0">consoleEncoder := zapcore.NewConsoleEncoder(encoderConfig)
        core := zapcore.NewCore(consoleEncoder, stdout, level)

        // Get build info for startup logging only
        buildInfo, _ := debug.ReadBuildInfo()

        // Create base logger
        logger := zap.New(core,
                zap.AddCaller(),
                zap.AddStacktrace(zapcore.ErrorLevel),
        )

        // Log startup information once
        logger.Debug("Starting Omnivex",
                zap.String("app_version", "1.0.0"),
                zap.String("go_version", buildInfo.GoVersion),
                zap.Int("pid", os.Getpid()),
                zap.Bool("verbose_mode", verbose),
        )

        // Return clean logger without default fields
        return logger, nil</span>
}

func main() <span class="cov0" title="0">{
        // Parse verbose flag
        verbose := false
        for _, arg := range os.Args[1:] </span><span class="cov0" title="0">{
                if arg == "--verbose" || arg == "-v" </span><span class="cov0" title="0">{
                        verbose = true
                        break</span>
                }
        }

        // Initialize logger
        <span class="cov0" title="0">logger, err := createLogger(verbose)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to initialize logger: %v", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                _ = logger.Sync()
        }</span>()

        // Execute root command
        <span class="cov0" title="0">if err := cmd.Execute(logger); err != nil </span><span class="cov0" title="0">{
                logger.Error("Application execution failed",
                        zap.Error(err),
                        zap.String("command", os.Args[0]),
                )
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package combine

import (
        "bufio"
        "bytes"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strings"
        "sync"

        "go.uber.org/zap"
)

// ==============================
// Configuration and Data Structures
// ==============================

// Arguments holds the configuration for the combine process.
type Arguments struct {
        Paths          []string // Files/directories to process
        Output         string   // Combined output file
        Tree           string   // Tree structure output file
        MaxFileSizeKB  int      // Maximum file size in KB
        MaxWorkers     int      // Number of concurrent workers
        IgnorePatterns []string // Command-line specified ignore patterns
        Verbose        bool     // Enable verbose logging of skipped files
}

// FileContent represents the content of a single file.
type FileContent struct {
        Path    string // Relative path to the file
        Content string // Formatted content of the file
}

// CollectedFiles holds lists of regular and binary files.
type CollectedFiles struct {
        Regular []string
        Binary  []string
}

// ==============================
// Execute Function
// ==============================

// ExecuteWithArgs is the main entry point for the combine package with custom arguments.
func ExecuteWithArgs(args Arguments, logger *zap.Logger) error <span class="cov0" title="0">{
        logger.Debug("Starting combine process", zap.Strings("paths", args.Paths))

        // Ensure output and tree directories exist
        if err := os.MkdirAll(filepath.Dir(args.Output), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create output directory", zap.String("path", args.Output), zap.Error(err))
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>
        <span class="cov0" title="0">if err := os.MkdirAll(filepath.Dir(args.Tree), os.ModePerm); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create tree output directory", zap.String("path", args.Tree), zap.Error(err))
                return fmt.Errorf("failed to create tree output directory: %w", err)
        }</span>

        // Load ignore patterns from default ignore file
        <span class="cov0" title="0">gi, err := LoadIgnoreFiles(".combineignore", "", logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to load default ignore patterns", zap.Error(err))
                return fmt.Errorf("failed to load default ignore patterns: %w", err)
        }</span>
        <span class="cov0" title="0">logger.Debug("Loaded ignore patterns", zap.Int("totalPatterns", len(gi.patterns)))

        // Compile command-line ignore patterns and add them to the ignore parser
        if len(args.IgnorePatterns) &gt; 0 </span><span class="cov0" title="0">{
                gi.CompileIgnoreLines(args.IgnorePatterns...)
                logger.Debug("Added command-line ignore patterns", zap.Int("count", len(args.IgnorePatterns)))
        }</span>

        // Combine files and generate tree structure
        <span class="cov0" title="0">if err := CombineFiles(args, gi, logger); err != nil </span><span class="cov0" title="0">{
                logger.Error("Combine process failed", zap.Error(err))
                return fmt.Errorf("combine process failed: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Combine process completed successfully",
                zap.String("output", args.Output),
                zap.String("tree", args.Tree),
        )
        return nil</span>
}

// ==============================
// File Processing Functions
// ==============================

// CombineFiles orchestrates the combination of files and tree generation.
func CombineFiles(args Arguments, gi IgnoreParser, logger *zap.Logger) error <span class="cov0" title="0">{
        logger.Debug("Starting file combination process",
                zap.Strings("inputPaths", args.Paths),
                zap.String("outputFile", args.Output),
                zap.Int("maxFileSizeKB", args.MaxFileSizeKB),
                zap.Int("maxWorkers", args.MaxWorkers))

        var allFilesToProcess []string
        var allBinaryFiles []string

        // Collect files to process for each path
        for _, path := range args.Paths </span><span class="cov0" title="0">{
                absPath, err := filepath.Abs(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to get absolute path",
                                zap.String("path", path),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">info, err := os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Path does not exist or cannot be accessed",
                                zap.String("path", absPath),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        parentDir := absPath
                        logger.Debug("Processing directory",
                                zap.String("dir", absPath),
                                zap.String("parentDir", parentDir))

                        collected, err := TraverseAndCollectFiles(absPath, gi, args.MaxFileSizeKB, logger, args.Verbose)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to traverse directory",
                                        zap.String("dir", absPath),
                                        zap.Error(err))
                                continue</span>
                        }
                        <span class="cov0" title="0">logger.Debug("Collected files from directory",
                                zap.String("dir", absPath),
                                zap.Int("regularFileCount", len(collected.Regular)),
                                zap.Int("binaryFileCount", len(collected.Binary)))
                        allFilesToProcess = append(allFilesToProcess, collected.Regular...)
                        allBinaryFiles = append(allBinaryFiles, collected.Binary...)</span>
                } else<span class="cov0" title="0"> if !shouldSkipFile(absPath, info, gi, args.MaxFileSizeKB, logger, args.Verbose) </span><span class="cov0" title="0">{
                        logger.Debug("Adding single file to process",
                                zap.String("file", absPath))
                        allFilesToProcess = append(allFilesToProcess, absPath)
                }</span> else<span class="cov0" title="0"> {
                        // Determine if the file was skipped due to being binary
                        isBinary, err := isBinaryFile(absPath)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to check if file is binary",
                                        zap.String("file", absPath),
                                        zap.Error(err))
                        }</span> else<span class="cov0" title="0"> if isBinary </span><span class="cov0" title="0">{
                                allBinaryFiles = append(allBinaryFiles, absPath)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(allBinaryFiles) &gt; 0 </span><span class="cov0" title="0">{
                // Inform the user about detected binary files
                logger.Warn("Detected binary files. These files are not included in the combined output:",
                        zap.Int("binaryFileCount", len(allBinaryFiles)),
                        zap.Strings("binaryFiles", allBinaryFiles))

                // Prompt the user to decide whether to continue
                shouldContinue, err := promptUser(fmt.Sprintf("Detected %d binary files. Do you want to continue and exclude these files? (y/n): ", len(allBinaryFiles)))
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to read user input",
                                zap.Error(err))
                        return fmt.Errorf("failed to read user input: %w", err)
                }</span>

                <span class="cov0" title="0">if !shouldContinue </span><span class="cov0" title="0">{
                        logger.Debug("User chose to abort the combine process due to detected binary files.")
                        return nil
                }</span>
        }

        <span class="cov0" title="0">if len(allFilesToProcess) == 0 </span><span class="cov0" title="0">{
                logger.Warn("No files to process after filtering.")
                return nil
        }</span>

        <span class="cov0" title="0">logger.Debug("Starting file processing",
                zap.Int("totalFiles", len(allFilesToProcess)))

        // Process files concurrently
        jobs := make(chan string, len(allFilesToProcess))
        results := make(chan FileContent, len(allFilesToProcess))

        var wg sync.WaitGroup
        numWorkers := args.MaxWorkers
        if numWorkers &lt;= 0 </span><span class="cov0" title="0">{
                numWorkers = runtime.NumCPU()
                logger.Debug("Adjusted worker count",
                        zap.Int("workers", numWorkers))
        }</span>

        <span class="cov0" title="0">logger.Debug("Initializing worker pool",
                zap.Int("workers", numWorkers))

        for w := 0; w &lt; numWorkers; w++ </span><span class="cov0" title="0">{
                wg.Add(1)
                workerLogger := logger.With(zap.Int("workerID", w))
                go Worker(w, jobs, results, filepath.Dir(args.Paths[0]), &amp;wg, workerLogger)
        }</span>

        // Send files to workers
        <span class="cov0" title="0">logger.Debug("Distributing files to workers")
        for _, file := range allFilesToProcess </span><span class="cov0" title="0">{
                jobs &lt;- file
        }</span>
        <span class="cov0" title="0">close(jobs)
        logger.Debug("All files distributed to workers")

        // Collect results in a separate goroutine
        var combinedContents []FileContent
        done := make(chan bool)
        go func() </span><span class="cov0" title="0">{
                for result := range results </span><span class="cov0" title="0">{
                        logger.Debug("Received processed file",
                                zap.String("file", result.Path))
                        combinedContents = append(combinedContents, result)
                }</span>
                <span class="cov0" title="0">done &lt;- true</span>
        }()

        // Wait for all workers to finish
        <span class="cov0" title="0">wg.Wait()
        close(results)
        &lt;-done

        logger.Debug("All files processed",
                zap.Int("processedFiles", len(combinedContents)))

        // Sort files for consistent output
        sort.Slice(combinedContents, func(i, j int) bool </span><span class="cov0" title="0">{
                return combinedContents[i].Path &lt; combinedContents[j].Path
        }</span>)
        <span class="cov0" title="0">logger.Debug("Sorted processed files")

        // Generate tree structure
        logger.Debug("Generating tree structure")

        treeBuilder := strings.Builder{}
        for _, path := range args.Paths </span><span class="cov0" title="0">{
                absPath, err := filepath.Abs(path)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Failed to get absolute path for tree",
                                zap.String("path", path),
                                zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">info, err := os.Stat(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Cannot stat path for tree", zap.String("path", absPath), zap.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        // Add the absolute path with a trailing '/' as the first line of the tree
                        treeBuilder.WriteString(absPath + "/\n")

                        tree := GenerateTreeStructure(absPath, absPath, gi, "", logger)
                        if tree != "" </span><span class="cov0" title="0">{
                                treeBuilder.WriteString(tree)
                                treeBuilder.WriteString("\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        relPath, relErr := filepath.Rel(filepath.Dir(absPath), absPath)
                        if relErr != nil </span><span class="cov0" title="0">{
                                relPath = absPath // Fallback to absolute path if relative path fails
                        }</span>
                        <span class="cov0" title="0">relPath = normalizePath(relPath)
                        treeBuilder.WriteString(relPath + "\n")</span>
                }
        }
        <span class="cov0" title="0">treeContent := treeBuilder.String()

        // Write tree structure to tree.txt
        logger.Debug("Writing tree structure to tree.txt", zap.String("treeFile", args.Tree))
        if err := os.WriteFile(args.Tree, []byte(treeContent), 0644); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to write tree structure", zap.String("treeFile", args.Tree), zap.Error(err))
                return fmt.Errorf("failed to write tree structure: %w", err)
        }</span>

        // Create combined.txt and write tree at the top
        <span class="cov0" title="0">logger.Debug("Writing combined content to combined.txt", zap.String("combinedFile", args.Output))
        if err := os.MkdirAll(filepath.Dir(args.Output), 0755); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create output directory",
                        zap.String("dir", filepath.Dir(args.Output)),
                        zap.Error(err))
                return fmt.Errorf("failed to create output directory: %w", err)
        }</span>

        <span class="cov0" title="0">outFile, err := os.Create(args.Output)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create output file",
                        zap.String("file", args.Output),
                        zap.Error(err))
                return fmt.Errorf("failed to create output file: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err := outFile.Close(); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to close output file",
                                zap.String("file", args.Output),
                                zap.Error(err))
                }</span>
        }()

        <span class="cov0" title="0">writer := bufio.NewWriter(outFile)

        // Write tree content first
        if _, err := writer.WriteString(treeContent); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to write tree content to combined file",
                        zap.String("file", args.Output),
                        zap.Error(err))
                return fmt.Errorf("failed to write tree content: %w", err)
        }</span>

        // Write combined file contents
        <span class="cov0" title="0">for _, content := range combinedContents </span><span class="cov0" title="0">{
                if _, err := writer.WriteString(content.Content); err != nil </span><span class="cov0" title="0">{
                        logger.Error("Failed to write content to combined file",
                                zap.String("file", args.Output),
                                zap.String("contentPath", content.Path),
                                zap.Error(err))
                        return fmt.Errorf("failed to write content: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if err := writer.Flush(); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to flush output file",
                        zap.String("file", args.Output),
                        zap.Error(err))
                return fmt.Errorf("failed to flush output: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Successfully combined files",
                zap.String("outputFile", args.Output),
                zap.Int("totalFiles", len(combinedContents)))
        return nil</span>
}

// ==============================
// File Processing Functions
// ==============================

// ProcessSingleFile reads and formats the content of a single file.
func ProcessSingleFile(filePath, parentDir string, logger *zap.Logger) (FileContent, error) <span class="cov0" title="0">{
        logger.Debug("Processing file",
                zap.String("filePath", filePath),
                zap.String("parentDir", parentDir))

        separatorLine := "# " + strings.Repeat("-", 78)
        relativePath, err := filepath.Rel(parentDir, filePath)
        if parentDir == "" || err != nil </span><span class="cov0" title="0">{
                logger.Warn("Unable to determine relative path, using absolute path",
                        zap.String("filePath", filePath),
                        zap.String("parentDir", parentDir),
                        zap.Error(err))
                relativePath = filePath
        }</span>
        <span class="cov0" title="0">relativePath = normalizePath(relativePath)

        header := fmt.Sprintf("\n\n%s\n# Source: %s #\n\n", separatorLine, relativePath)

        logger.Debug("Reading file content",
                zap.String("filePath", filePath))
        fileContent, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to read file",
                        zap.String("filePath", filePath),
                        zap.Error(err))
                return FileContent{}, fmt.Errorf("error reading file %s: %w", filePath, err)
        }</span>

        <span class="cov0" title="0">logger.Debug("Successfully read file content",
                zap.String("filePath", filePath),
                zap.Int("contentSizeBytes", len(fileContent)))

        return FileContent{
                Path:    relativePath,
                Content: header + string(fileContent),
        }, nil</span>
}

// Worker processes files from the jobs channel and sends results to the results channel.
func Worker(id int, jobs &lt;-chan string, results chan&lt;- FileContent, parentDir string, wg *sync.WaitGroup, logger *zap.Logger) <span class="cov0" title="0">{
        defer wg.Done()
        logger.Debug("Worker started", zap.Int("workerID", id))

        for file := range jobs </span><span class="cov0" title="0">{
                logger.Debug("Worker received file to process",
                        zap.Int("workerID", id),
                        zap.String("filePath", file))

                content, err := ProcessSingleFile(file, parentDir, logger)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("Worker failed to process file",
                                zap.Int("workerID", id),
                                zap.String("filePath", file),
                                zap.Error(err))
                        continue</span> // Optionally, decide whether to stop processing on error
                }

                <span class="cov0" title="0">results &lt;- content
                logger.Debug("Worker successfully processed file",
                        zap.Int("workerID", id),
                        zap.String("filePath", file))</span>
        }

        <span class="cov0" title="0">logger.Debug("Worker finished processing", zap.Int("workerID", id))</span>
}

// ==============================
// File Traversal and Collection
// ==============================

// TraverseAndCollectFiles collects files to process based on the ignore rules, size limits, and binary detection
func TraverseAndCollectFiles(parentDir string, gi IgnoreParser, maxFileSizeKB int, logger *zap.Logger, verbose bool) (CollectedFiles, error) <span class="cov0" title="0">{
        var collected CollectedFiles
        logger.Debug("Starting file traversal and collection",
                zap.String("parentDir", parentDir),
                zap.Int("maxFileSizeKB", maxFileSizeKB))

        err := filepath.WalkDir(parentDir, func(path string, d fs.DirEntry, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("Error accessing path during traversal",
                                zap.String("path", path),
                                zap.Error(err))
                        return nil // Ignore errors accessing files or directories
                }</span>

                <span class="cov0" title="0">relPath, _ := filepath.Rel(parentDir, path)
                relPath = normalizePath(relPath)

                logger.Debug("Evaluating path against ignore patterns",
                        zap.String("path", path),
                        zap.String("relPath", relPath))

                if d.IsDir() &amp;&amp; gi.MatchesPath(relPath) </span><span class="cov0" title="0">{
                        logger.Debug("Skipping ignored directory during traversal",
                                zap.String("directory", path))
                        return filepath.SkipDir // Skip ignored directories
                }</span>

                <span class="cov0" title="0">if !d.IsDir() &amp;&amp; !gi.MatchesPath(relPath) </span><span class="cov0" title="0">{
                        // Check if the file is a binary file
                        isBinary, err := isBinaryFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to check if file is binary during traversal",
                                        zap.String("filePath", path),
                                        zap.Error(err))
                                return nil
                        }</span>

                        <span class="cov0" title="0">if isBinary </span><span class="cov0" title="0">{
                                collected.Binary = append(collected.Binary, path)
                                if verbose </span><span class="cov0" title="0">{
                                        logger.Debug("Detected binary file during traversal",
                                                zap.String("filePath", path))
                                }</span>
                                <span class="cov0" title="0">return nil</span> // Do not include binary files in the regular list
                        }

                        // Check file size
                        <span class="cov0" title="0">info, err := d.Info()
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to get file info during traversal",
                                        zap.String("filePath", path),
                                        zap.Error(err))
                                return nil
                        }</span>

                        <span class="cov0" title="0">if info.Size() &gt; int64(maxFileSizeKB)*1024 </span><span class="cov0" title="0">{
                                if verbose </span><span class="cov0" title="0">{
                                        logger.Debug("Skipping file due to size limit during traversal",
                                                zap.String("filePath", path),
                                                zap.Int64("sizeBytes", info.Size()))
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        }

                        // Add to regular files
                        <span class="cov0" title="0">collected.Regular = append(collected.Regular, path)
                        logger.Debug("Added file to processing list during traversal",
                                zap.String("filePath", path))</span>
                }

                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                logger.Error("Error during file traversal", zap.Error(err))
        }</span> else<span class="cov0" title="0"> {
                logger.Debug("Completed file traversal and collection",
                        zap.Int("regularFiles", len(collected.Regular)),
                        zap.Int("binaryFiles", len(collected.Binary)))
        }</span>

        <span class="cov0" title="0">return collected, err</span>
}

// ==============================
// Helper Functions
// ==============================

// shouldSkipFile determines if a file should be skipped based on ignore patterns, size, and binary content.
func shouldSkipFile(path string, info fs.FileInfo, gi IgnoreParser, maxFileSizeKB int, logger *zap.Logger, verbose bool) bool <span class="cov0" title="0">{
        relPath, _ := filepath.Rel(filepath.Dir(path), path)
        relPath = normalizePath(relPath)

        if gi.MatchesPath(relPath) </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        logger.Debug("File matches ignore pattern",
                                zap.String("file", path),
                                zap.String("relPath", relPath))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">if isCommonBinaryExtension(path) </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        logger.Debug("File has binary extension",
                                zap.String("file", path),
                                zap.String("extension", filepath.Ext(path)))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">if info.Size() &gt; int64(maxFileSizeKB)*1024 </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        logger.Debug("File exceeds size limit",
                                zap.String("file", path),
                                zap.Int64("size", info.Size()),
                                zap.Int("maxSizeKB", maxFileSizeKB))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">isBinary, err := isBinaryFile(path)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to check if file is binary",
                        zap.String("file", path),
                        zap.Error(err))
                return true
        }</span>

        <span class="cov0" title="0">if isBinary </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        logger.Debug("File is binary",
                                zap.String("file", path))
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">return false</span>
}

// promptUser displays a message and waits for the user to enter 'y' or 'n'.
// Returns true if the user enters 'y' or 'yes' (case-insensitive), false otherwise.
func promptUser(message string) (bool, error) <span class="cov0" title="0">{
        fmt.Print(message)
        reader := bufio.NewReader(os.Stdin)
        response, err := reader.ReadString('\n')
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">response = strings.TrimSpace(strings.ToLower(response))
        return response == "y" || response == "yes", nil</span>
}

// normalizePath converts the OS-specific path separators to forward slashes.
func normalizePath(path string) string <span class="cov0" title="0">{
        return filepath.ToSlash(path)
}</span>

// ==============================
// Binary Detection Functionality
// ==============================

// isBinaryFile checks if a file is likely to be binary by reading its first few bytes
// and checking for null bytes or a high ratio of non-printable characters
func isBinaryFile(filePath string) (bool, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        // Read first 512 bytes to check content type
        buffer := make([]byte, 512)
        n, err := file.Read(buffer)
        if err != nil &amp;&amp; !errors.Is(err, io.EOF) </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">buffer = buffer[:n]

        // Check for null bytes (common in binary files)
        if bytes.Contains(buffer, []byte{0}) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Count non-printable characters
        <span class="cov0" title="0">nonPrintable := 0
        for _, b := range buffer </span><span class="cov0" title="0">{
                if !isPrintable(b) </span><span class="cov0" title="0">{
                        nonPrintable++
                }</span>
        }

        // If more than 30% non-printable characters, consider it binary
        <span class="cov0" title="0">if len(buffer) == 0 </span><span class="cov0" title="0">{
                return false, nil // Empty files are considered text
        }</span>
        <span class="cov0" title="0">return float64(nonPrintable)/float64(len(buffer)) &gt; 0.3, nil</span>
}

// isPrintable checks if a byte represents a printable ASCII character
func isPrintable(b byte) bool <span class="cov0" title="0">{
        return (b &gt;= 32 &amp;&amp; b &lt;= 126) || b == '\n' || b == '\r' || b == '\t'
}</span>

// Common binary file extensions to auto-ignore
var binaryExtensions = map[string]bool{
        ".exe":      true,
        ".dll":      true,
        ".so":       true,
        ".dylib":    true,
        ".bin":      true,
        ".obj":      true,
        ".o":        true,
        ".a":        true,
        ".lib":      true,
        ".pyc":      true,
        ".pyo":      true,
        ".class":    true,
        ".jar":      true,
        ".war":      true,
        ".ear":      true,
        ".png":      true,
        ".jpg":      true,
        ".jpeg":     true,
        ".gif":      true,
        ".bmp":      true,
        ".ico":      true,
        ".pdf":      true,
        ".zip":      true,
        ".tar":      true,
        ".gz":       true,
        ".7z":       true,
        ".rar":      true,
        ".db":       true,
        ".sqlite":   true,
        ".mp3":      true,
        ".mp4":      true,
        ".avi":      true,
        ".mov":      true,
        ".wmv":      true,
        ".flac":     true,
        ".m4a":      true,
        ".mkv":      true,
        ".wav":      true,
        ".iso":      true,
        ".dmg":      true,
        ".pkg":      true,
        ".deb":      true,
        ".rpm":      true,
        ".msi":      true,
        ".apk":      true,
        ".ipa":      true,
        ".svg":      true,
        ".webp":     true,
        ".heic":     true,
        ".psd":      true,
        ".ttf":      true,
        ".otf":      true,
        ".woff":     true,
        ".woff2":    true,
        ".eot":      true,
        ".dbf":      true,
        ".mdb":      true,
        ".accdb":    true,
        ".bak":      true,
        ".tmp":      true,
        ".log":      true,
        ".cache":    true,
        ".swp":      true,
        ".swo":      true,
        ".DS_Store": true,
}

// isCommonBinaryExtension checks if the file has a known binary extension
func isCommonBinaryExtension(path string) bool <span class="cov0" title="0">{
        ext := strings.ToLower(filepath.Ext(path))
        return binaryExtensions[ext]
}</span>

// ==============================
// Ignore Functionality
// ==============================

// IgnoreParser defines the interface for matching paths against ignore patterns.
type IgnoreParser interface {
        // MatchesPath returns true if the given path matches any of the ignore patterns.
        MatchesPath(path string) bool
        // MatchesPathWithPattern returns true and the matching IgnorePattern if the given path matches any ignore pattern.
        MatchesPathWithPattern(path string) (bool, *IgnorePattern)
}

// IgnorePattern encapsulates a compiled regular expression pattern,
// a negation flag, and metadata about the pattern's origin.
type IgnorePattern struct {
        Pattern *regexp.Regexp // Compiled regular expression for the pattern.
        Negate  bool           // Indicates if the pattern is a negation (starts with '!').
        LineNo  int            // Line number in the source (1-based).
        Line    string         // Original pattern line.
}

// GitIgnore represents a collection of ignore patterns.
type GitIgnore struct {
        patterns []*IgnorePattern // Slice of compiled ignore patterns.
        logger   *zap.Logger      // Logger for debug information.
}

// NewGitIgnore initializes a GitIgnore instance with a provided logger.
func NewGitIgnore(logger *zap.Logger) *GitIgnore <span class="cov0" title="0">{
        if logger == nil </span><span class="cov0" title="0">{
                // Fallback to a no-op logger if none is provided to avoid nil pointer dereferences
                logger = zap.NewNop()
        }</span>
        <span class="cov0" title="0">return &amp;GitIgnore{
                patterns: []*IgnorePattern{},
                logger:   logger,
        }</span>
}

// LoadIgnoreFiles loads ignore patterns from local and global ignore files.
func LoadIgnoreFiles(localPath, globalPath string, logger *zap.Logger) (*GitIgnore, error) <span class="cov0" title="0">{
        gi := NewGitIgnore(logger) // Use the provided logger.

        // Initialize the .combineignore file with default patterns if it doesn't exist
        if localPath == "" </span><span class="cov0" title="0">{
                localPath = "./.combineignore"
                logger.Debug("Local ignore path not specified; defaulting to ./.combineignore")
                absLocalPath, err := filepath.Abs(localPath)
                if err != nil </span><span class="cov0" title="0">{
                        gi.logger.Warn("Failed to get absolute path for default local ignore file",
                                zap.String("filePath", localPath),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        if _, err := os.Stat(absLocalPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                // Create .combineignore with default ignore patterns if it does not exist
                                defaultPatterns := []string{
                                        ".git/",          // Ignore the .git directory
                                        ".combineignore", // Ignore the .combineignore file itself
                                        "debug/",         // Ignore the debug directory
                                }
                                if err := os.WriteFile(absLocalPath, []byte(strings.Join(defaultPatterns, "\n")), 0644); err != nil </span><span class="cov0" title="0">{
                                        gi.logger.Error("Failed to create .combineignore file",
                                                zap.String("file", absLocalPath),
                                                zap.Error(err))
                                        return nil, fmt.Errorf("failed to create .combineignore file: %w", err)
                                }</span>
                                <span class="cov0" title="0">gi.logger.Debug("Created default .combineignore file",
                                        zap.String("file", absLocalPath),
                                        zap.String("location", absLocalPath))</span>
                        } else<span class="cov0" title="0"> {
                                gi.logger.Debug("Default .combineignore file already exists",
                                        zap.String("file", absLocalPath),
                                        zap.String("location", absLocalPath))
                        }</span>
                }
        }

        // Load global ignore file if specified
        <span class="cov0" title="0">if globalPath != "" </span><span class="cov0" title="0">{
                absGlobalPath, err := filepath.Abs(globalPath)
                if err != nil </span><span class="cov0" title="0">{
                        gi.logger.Warn("Failed to get absolute path for global ignore file",
                                zap.String("globalPath", globalPath),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("Attempting to load global ignore file",
                                zap.String("file", absGlobalPath))
                        if err := gi.CompileIgnoreFile(absGlobalPath); err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        gi.logger.Debug("Global ignore file does not exist and will be skipped",
                                                zap.String("file", absGlobalPath))
                                }</span> else<span class="cov0" title="0"> {
                                        gi.logger.Error("Failed to compile global ignore file",
                                                zap.String("file", absGlobalPath),
                                                zap.Error(err))
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                gi.logger.Debug("Successfully loaded global ignore file",
                                        zap.String("file", absGlobalPath))
                        }</span>
                }
        }

        // Load local ignore file if specified
        <span class="cov0" title="0">if localPath != "" </span><span class="cov0" title="0">{
                absLocalPath, err := filepath.Abs(localPath)
                if err != nil </span><span class="cov0" title="0">{
                        gi.logger.Warn("Failed to get absolute path for local ignore file",
                                zap.String("localPath", localPath),
                                zap.Error(err))
                }</span> else<span class="cov0" title="0"> {
                        logger.Debug("Attempting to load local ignore file",
                                zap.String("file", absLocalPath))
                        if err := gi.CompileIgnoreFile(absLocalPath); err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        gi.logger.Debug("Local ignore file does not exist and will be skipped",
                                                zap.String("file", absLocalPath))
                                }</span> else<span class="cov0" title="0"> {
                                        gi.logger.Error("Failed to compile local ignore file",
                                                zap.String("file", absLocalPath),
                                                zap.Error(err))
                                        return nil, err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                gi.logger.Debug("Successfully loaded local ignore file",
                                        zap.String("file", absLocalPath))
                        }</span>
                }
        }

        <span class="cov0" title="0">gi.logger.Debug("Finished loading ignore files",
                zap.Int("totalPatterns", len(gi.patterns)))

        return gi, nil</span>
}

// CompileIgnoreLines compiles a set of ignore pattern lines into a GitIgnore instance.
// It accepts a variadic number of pattern strings.
func (gi *GitIgnore) CompileIgnoreLines(lines ...string) <span class="cov0" title="0">{
        for i, line := range lines </span><span class="cov0" title="0">{
                pattern, negate := parsePatternLine(line, len(gi.patterns)+i+1, gi.logger)
                if pattern != nil </span><span class="cov0" title="0">{
                        ip := &amp;IgnorePattern{
                                Pattern: pattern,
                                Negate:  negate,
                                LineNo:  len(gi.patterns) + i + 1, // 1-based line numbering.
                                Line:    line,
                        }
                        gi.patterns = append(gi.patterns, ip)
                        gi.logger.Debug("Compiled ignore pattern",
                                zap.Int("lineNo", ip.LineNo),
                                zap.String("pattern", ip.Line),
                                zap.Bool("negate", ip.Negate))
                }</span>
        }
}

// CompileIgnoreFile reads an ignore file from the given path, parses its lines,
// and compiles them into the GitIgnore instance.
func (gi *GitIgnore) CompileIgnoreFile(filePath string) error <span class="cov0" title="0">{
        gi.logger.Debug("Starting to compile ignore file", zap.String("filePath", filePath))
        content, err := os.ReadFile(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        gi.logger.Debug("Ignore file does not exist and will be skipped",
                                zap.String("filePath", filePath))
                        return nil
                }</span>
                <span class="cov0" title="0">gi.logger.Error("Failed to read ignore file",
                        zap.String("filePath", filePath),
                        zap.Error(err))
                return err</span>
        }

        <span class="cov0" title="0">lines := strings.Split(string(content), "\n")
        gi.logger.Debug("Read ignore file lines",
                zap.String("filePath", filePath),
                zap.Int("lineCount", len(lines)))
        for i, line := range lines </span><span class="cov0" title="0">{
                pattern, negate := parsePatternLine(line, i+1, gi.logger)
                if pattern != nil </span><span class="cov0" title="0">{
                        ip := &amp;IgnorePattern{
                                Pattern: pattern,
                                Negate:  negate,
                                LineNo:  i + 1, // 1-based line numbering.
                                Line:    line,
                        }
                        gi.patterns = append(gi.patterns, ip)
                        gi.logger.Debug("Compiled ignore pattern from file",
                                zap.String("filePath", filePath),
                                zap.Int("lineNo", ip.LineNo),
                                zap.String("pattern", ip.Line),
                                zap.Bool("negate", ip.Negate))
                }</span> else<span class="cov0" title="0"> {
                        gi.logger.Debug("Skipped empty or comment line in ignore file",
                                zap.String("filePath", filePath),
                                zap.Int("lineNo", i+1))
                }</span>
        }
        <span class="cov0" title="0">gi.logger.Debug("Compiled ignore patterns from file",
                zap.String("filePath", filePath),
                zap.Int("patternCount", len(lines)))
        return nil</span>
}

// MatchesPath checks if the given path matches any of the ignore patterns.
// It returns true if the path should be ignored.
func (gi *GitIgnore) MatchesPath(path string) bool <span class="cov0" title="0">{
        matches, _ := gi.MatchesPathWithPattern(path)
        return matches
}</span>

// MatchesPathWithPattern checks if the given path matches any ignore pattern.
// It returns a boolean indicating a match and the specific IgnorePattern that matched.
func (gi *GitIgnore) MatchesPathWithPattern(path string) (bool, *IgnorePattern) <span class="cov0" title="0">{
        normalizedPath := normalizePath(path)

        matched := false
        var matchedPattern *IgnorePattern

        for _, pattern := range gi.patterns </span><span class="cov0" title="0">{
                if pattern.Pattern.MatchString(normalizedPath) </span><span class="cov0" title="0">{
                        if pattern.Negate </span><span class="cov0" title="0">{
                                matched = false
                                matchedPattern = pattern
                        }</span> else<span class="cov0" title="0"> {
                                matched = true
                                matchedPattern = pattern
                        }</span>
                        // Note: The last matching pattern determines the outcome.
                }
        }

        <span class="cov0" title="0">return matched, matchedPattern</span>
}

// Patterns returns the original pattern lines used to compile the GitIgnore.
func (gi *GitIgnore) Patterns() []string <span class="cov0" title="0">{
        var patterns []string
        for _, p := range gi.patterns </span><span class="cov0" title="0">{
                patterns = append(patterns, p.Line)
        }</span>
        <span class="cov0" title="0">return patterns</span>
}

// CompileIgnoreFileAndLines reads an ignore file and appends additional lines,
// compiling all into the existing GitIgnore instance.
func CompileIgnoreFileAndLines(filePath string, gi *GitIgnore, additionalLines ...string) error <span class="cov0" title="0">{
        // Compile patterns from the ignore file
        if err := gi.CompileIgnoreFile(filePath); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Compile additional lines
        <span class="cov0" title="0">gi.CompileIgnoreLines(additionalLines...)
        return nil</span>
}

// parsePatternLine processes a single line from an ignore file and returns
// a compiled regular expression and a negation flag.
// Returns nil if the line is a comment or empty.
func parsePatternLine(line string, lineNo int, logger *zap.Logger) (*regexp.Regexp, bool) <span class="cov0" title="0">{
        trimmedLine := strings.TrimRight(line, "\r\n")

        // 1. Ignore empty lines
        if trimmedLine == "" </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // 2. Ignore comments
        <span class="cov0" title="0">if strings.HasPrefix(trimmedLine, "#") </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        // 3. Trim surrounding whitespace
        <span class="cov0" title="0">trimmedLine = strings.TrimSpace(trimmedLine)

        // 4. Handle negation
        negate := false
        if strings.HasPrefix(trimmedLine, "!") </span><span class="cov0" title="0">{
                negate = true
                trimmedLine = strings.TrimPrefix(trimmedLine, "!")
        }</span>

        // 5. Handle escaped characters '#' or '!'
        <span class="cov0" title="0">if strings.HasPrefix(trimmedLine, "\\#") || strings.HasPrefix(trimmedLine, "\\!") </span><span class="cov0" title="0">{
                trimmedLine = trimmedLine[1:]
        }</span>

        // 6. Prepend '/' if pattern contains a wildcard in a directory and doesn't start with '/'
        <span class="cov0" title="0">if wildcardDirPattern.MatchString(trimmedLine) &amp;&amp; !strings.HasPrefix(trimmedLine, "/") </span><span class="cov0" title="0">{
                trimmedLine = "/" + trimmedLine
        }</span>

        // 7. Escape '.' characters
        <span class="cov0" title="0">escapedLine := escapeSpecialChars(trimmedLine)

        // 8. Replace '/**/' with "(/|/.+/)"
        escapedLine = handleDoubleStarPatterns(escapedLine)

        // 9. Convert wildcards '*' and '?' to regex equivalents
        regexPattern := wildcardToRegex(escapedLine)

        // 10. Anchor the pattern to match the entire path
        regexPattern = anchorPattern(regexPattern, trimmedLine)

        compiledRegex, err := regexp.Compile(regexPattern)
        if err != nil </span><span class="cov0" title="0">{
                // Log invalid regex patterns with line number
                logger.Error("Invalid regex pattern",
                        zap.String("originalPattern", trimmedLine),
                        zap.String("compiledRegex", regexPattern),
                        zap.Int("lineNo", lineNo),
                        zap.Error(err),
                )
                return nil, false
        }</span>

        <span class="cov0" title="0">return compiledRegex, negate</span>
}

// escapeSpecialChars escapes regex special characters except for '*', '?', and '/'.
func escapeSpecialChars(pattern string) string <span class="cov0" title="0">{
        var specialChars = `.+()|^$[]{}`
        for _, char := range specialChars </span><span class="cov0" title="0">{
                pattern = strings.ReplaceAll(pattern, string(char), `\`+string(char))
        }</span>
        <span class="cov0" title="0">return pattern</span>
}

// handleDoubleStarPatterns replaces '**' patterns with appropriate regex.
func handleDoubleStarPatterns(pattern string) string <span class="cov0" title="0">{
        // Replace "/**/" with "(/|/.+/)"
        pattern = doubleStarPattern1.ReplaceAllString(pattern, `(/|/.+/)`)

        // Replace "/**" with "(/.*)?"
        pattern = doubleStarPattern2.ReplaceAllString(pattern, `(/.*)?`)

        // Replace "**/" with "(.*/)?"
        pattern = doubleStarPattern3.ReplaceAllString(pattern, `(.*/)?`)

        return pattern
}</span>

// wildcardToRegex converts wildcard patterns '*' and '?' to regex equivalents.
func wildcardToRegex(pattern string) string <span class="cov0" title="0">{
        // Replace '*' with '[^/]*' to match any character except '/'
        pattern = wildcardReplaceStar.ReplaceAllString(pattern, `[^/]*`)

        // Replace '?' with '.' to match any single character
        pattern = strings.ReplaceAll(pattern, "?", ".")
        return pattern
}</span>

// anchorPattern anchors the regex pattern to match the entire path.
func anchorPattern(pattern string, originalPattern string) string <span class="cov0" title="0">{
        if strings.HasSuffix(originalPattern, "/") </span><span class="cov0" title="0">{
                pattern += "(|.*)$"
        }</span> else<span class="cov0" title="0"> {
                pattern += "(|/.*)$"
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(pattern, "/") </span><span class="cov0" title="0">{
                return "^" + pattern
        }</span>
        <span class="cov0" title="0">return "^(|.*/)" + pattern</span>
}

// ==============================
// Precompiled Regular Expressions
// ==============================

var (
        // wildcardDirPattern detects patterns with wildcards in directories, e.g., "folder/*.ext"
        wildcardDirPattern = regexp.MustCompile(`[^/]\*/`)

        // doubleStarPattern1 matches "/**/" for replacement
        doubleStarPattern1 = regexp.MustCompile(`/\*\*/`)

        // doubleStarPattern2 matches "/**" at the end for replacement
        doubleStarPattern2 = regexp.MustCompile(`/\*\*$`)

        // doubleStarPattern3 matches "**/" at the beginning for replacement
        doubleStarPattern3 = regexp.MustCompile(`^\*\*/`)

        // wildcardReplaceStar replaces '*' with '[^/]*'
        wildcardReplaceStar = regexp.MustCompile(`\*`)
)

// ==============================
// Tree Structure Generation
// ==============================

// GenerateTreeStructure builds a visual tree representation of the directory.
func GenerateTreeStructure(directory, parentDir string, gi IgnoreParser, prefix string, logger *zap.Logger) string <span class="cov0" title="0">{
        var output []string

        entries, err := os.ReadDir(directory)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warn("Failed to read directory for tree structure", zap.String("directory", directory), zap.Error(err))
                return "" // If directory can't be read, skip
        }</span>

        // Sort entries: directories first, then files, alphabetically
        <span class="cov0" title="0">sort.Slice(entries, func(i, j int) bool </span><span class="cov0" title="0">{
                if entries[i].IsDir() != entries[j].IsDir() </span><span class="cov0" title="0">{
                        return entries[i].IsDir()
                }</span>
                <span class="cov0" title="0">return strings.ToLower(entries[i].Name()) &lt; strings.ToLower(entries[j].Name())</span>
        })

        <span class="cov0" title="0">for i, entry := range entries </span><span class="cov0" title="0">{
                connector := " "
                extension := "   "
                if i == len(entries)-1 </span><span class="cov0" title="0">{
                        connector = " "
                        extension = "    "
                }</span>

                <span class="cov0" title="0">entryPath := filepath.Join(directory, entry.Name())
                relPath, _ := filepath.Rel(parentDir, entryPath)
                relPath = normalizePath(relPath)

                if entry.IsDir() </span><span class="cov0" title="0">{
                        if gi.MatchesPath(relPath) </span><span class="cov0" title="0">{
                                logger.Debug("Skipping ignored directory in tree",
                                        zap.String("directory", entryPath))
                                continue</span> // Skip ignored directories
                        }
                        // Append '/' to directory names
                        <span class="cov0" title="0">output = append(output, fmt.Sprintf("%s%s%s/", prefix, connector, entry.Name()))
                        subtree := GenerateTreeStructure(entryPath, parentDir, gi, prefix+extension, logger)
                        if subtree != "" </span><span class="cov0" title="0">{
                                output = append(output, subtree)
                        }</span>
                } else<span class="cov0" title="0"> {
                        if !gi.MatchesPath(relPath) </span><span class="cov0" title="0">{
                                output = append(output, fmt.Sprintf("%s%s%s", prefix, connector, entry.Name()))
                        }</span>
                }
        }

        <span class="cov0" title="0">return strings.Join(output, "\n")</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package version

import (
        "fmt"
        "runtime"
)

var (
        // These will be populated by the compiler using -ldflags
        Version   = "dev"
        Commit    = "none"
        BuildTime = "unknown"
)

// Info contains version information
type Info struct {
        Version   string
        GitCommit string
        BuildTime string
        GoVersion string
        Platform  string
}

// Get returns the version info
func Get() Info <span class="cov0" title="0">{
        return Info{
                Version:   Version,
                GitCommit: Commit,
                BuildTime: BuildTime,
                GoVersion: runtime.Version(),
                Platform:  fmt.Sprintf("%s/%s", runtime.GOOS, runtime.GOARCH),
        }
}</span>

// String returns version information as a string
func (i Info) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Version: %s\nGit Commit: %s\nBuild Time: %s\nGo Version: %s\nPlatform: %s",
                i.Version,
                i.GitCommit,
                i.BuildTime,
                i.GoVersion,
                i.Platform,
        )
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
