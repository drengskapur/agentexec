name: Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    environment:
      name: production

    env:
      VERSION: ${{ github.ref_name }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@41dfa10bad2bb2ae585af6ee5bb4d7d973ad74ed # v5.1.0
        with:
          go-version: '1.23'
          cache: true

      - name: Install Dependencies
        run: go mod tidy

      - name: Run Tests
        run: go test ./... -v -race -coverprofile=coverage.out

      - name: Build and Package
        run: |
          mkdir -p build/${{ env.VERSION }}
          for os in windows linux darwin; do
            case $os in
              windows)
                ext=".exe"
                ;;
              *)
                ext=""
                ;;
            esac
            
            GOOS=$os GOARCH=amd64 go build -ldflags="-s -w \
              -X 'omnivex/pkg/version.Version=${{ env.VERSION }}' \
              -X 'omnivex/pkg/version.Commit=$(git rev-parse --short HEAD)' \
              -X 'omnivex/pkg/version.BuildTime=$(date -u +%Y-%m-%dT%H:%M:%SZ)'" \
              -o "build/${{ env.VERSION }}/omnivex-${{ env.VERSION }}-${os}-amd64${ext}" main.go

            # Package binaries
            if [ "$os" = "windows" ]; then
              (cd "build/${{ env.VERSION }}" && zip "omnivex-${{ env.VERSION }}-${os}-amd64.zip" "omnivex-${{ env.VERSION }}-${os}-amd64${ext}")
            else
              tar -czf "build/${{ env.VERSION }}/omnivex-${{ env.VERSION }}-${os}-amd64.tar.gz" -C "build/${{ env.VERSION }}" "omnivex-${{ env.VERSION }}-${os}-amd64"
            fi
          done

          # Generate Checksums
          cd "build/${{ env.VERSION }}"
          sha256sum * > checksums.txt
          
          # Create final assets archive
          zip -r "../omnivex-${{ env.VERSION }}-assets.zip" *

      - name: Generate Release Notes
        id: release_notes
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea # v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const tag = context.ref.replace('refs/tags/', '');
            
            let latestRelease;
            try {
              latestRelease = await github.rest.repos.getLatestRelease({
                owner,
                repo,
              });
            } catch (error) {
              console.log('No previous release found');
            }

            const since = latestRelease ? latestRelease.data.published_at : '1970-01-01T00:00:00Z';

            const pullRequests = await github.rest.pulls.list({
              owner,
              repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100,
            });

            const mergedPRs = pullRequests.data.filter(pr => 
              pr.merged_at && new Date(pr.merged_at) > new Date(since)
            );

            let releaseNotes = `## Release ${tag}\n\n`;

            if (mergedPRs.length === 0) {
              releaseNotes += '### Changes\n\n- No changes\n';
            } else {
              const categories = {
                '🚀 Features': [],
                '🐛 Bug Fixes': [],
                '🛠 Maintenance': [],
                'Other': []
              };

              mergedPRs.forEach(pr => {
                const labels = pr.labels.map(label => label.name);
                if (labels.includes('feature')) {
                  categories['🚀 Features'].push(pr);
                } else if (labels.includes('bug')) {
                  categories['🐛 Bug Fixes'].push(pr);
                } else if (labels.includes('chore') || labels.includes('refactor')) {
                  categories['🛠 Maintenance'].push(pr);
                } else {
                  categories['Other'].push(pr);
                }
              });

              for (const [category, prs] of Object.entries(categories)) {
                if (prs.length > 0) {
                  releaseNotes += `### ${category}\n\n`;
                  prs.forEach(pr => {
                    releaseNotes += `- ${pr.title} (@${pr.user.login} #${pr.number})\n`;
                  });
                  releaseNotes += '\n';
                }
              }
            }
            
            return releaseNotes;

      - name: Create GitHub Release
        uses: softprops/action-gh-release@01570a1f39cb168c169c802c3bceb9e93fb10974 # v2.1.0
        with:
          name: Release ${{ env.VERSION }}
          body: ${{ steps.release_notes.outputs.result }}
          draft: false
          prerelease: ${{ contains(github.ref_name, '-') }}
          files: |
            ./build/${{ env.VERSION }}/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}